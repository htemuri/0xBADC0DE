---
title: Howdy!
description: Home Page
author: Harris Temuri – Platform Engineer
---

My day-to-day started feeling a bit routine, so I decided to shake things up and learn some stuff in depth. This blog is where I’ll keep track of my explorations--from computer architecture and operating systems to networking, SRE best practices, and whatever else catches my interest. Below is the phased roadmap I’m using to stay organized.

---

## Roadmap

| **Phase** | **Focus**                                                                         | **Projects**                                                 |
|-----------|-----------------------------------------------------------------------------------|------------------------------------------------------------------|
| Phase 1   | Computer Architecture                                                             | Cache Benchmarks, NUMA Tests                                     |
| Phase 2   | OS & Kernel Tuning                                                               | PREEMPT_RT Kernel, Syscall Profiling                             |
| Phase 3   | Networking & Low-Latency                                                          | Low-Latency Router Config, DPDK Experiments                      |
| Phase 4   | Observability & Monitoring                                                        | Prometheus + Grafana Dashboards, eBPF Tracing                    |
| Phase 5   | High-Performance Programming & Concurrency                                        | Lock-Free Ring Buffer, Multi-threaded Order Book                 |
| Phase 6   | Hardware Acceleration & FPGA/Electronics                                          | FPGA Timestamping, Advanced NIC Offload                          |


### Computer Architecture & Basics

#### Reading Tasks
- [ ] Read “Computer Architecture: A Quantitative Approach” by Hennessy & Patterson  
- [ ] Skim CPU-related sections in “Systems Performance” by Brendan Gregg  

#### Project Tasks
- [ ] **CPU Cache Benchmarking**  
  - Write a C/C++ program to measure performance for arrays sized to fit/unfit L1/L2/L3 caches  
  - Use `perf` or `cachegrind` to gather data on cache misses and branch mispredictions  
- [ ] **NUMA-Aware Memory Allocation**  
  - Use `numactl` to bind processes to a specific NUMA node  
  - Benchmark memory throughput/latency with tools like `mbw` or `lmbench`  

**Milestones**  
- [ ] Have logs/graphs showing cache and NUMA performance differences  
- [ ] Gain a solid understanding of branch prediction, cache hierarchies, and NUMA fundamentals  

---

### Operating Systems & Kernel Tuning

#### Reading Tasks
- [ ] Read “Operating System Concepts” by Silberschatz, Galvin, Gagne  
- [ ] Study the scheduling and memory management chapters in “Linux Kernel Development” by Robert Love  

#### Project Tasks
- [ ] **Custom Low-Latency Kernel**  
  - Compile a **PREEMPT_RT**-patched kernel  
  - Use `cyclictest` to measure improvements in real-time scheduling  
- [ ] **Syscall Profiling & Minimization**  
  - Use `strace` or eBPF to measure syscall overhead  
  - Implement a ring buffer in userspace; compare its performance with `read()/write()`  

**Milestones**  
- [ ] Be able to explain how various schedulers affect latency  
- [ ] Have a working RT kernel with documented latency gains  

---

### Networking & Low-Latency Optimization

#### Reading Tasks
- [ ] Read “TCP/IP Illustrated” Vol. 1 by W. Richard Stevens  
- [ ] Review DPDK or Solarflare Onload documentation  

#### Project Tasks
- [ ] **UDP Multicast Feed Handler**  
  - Configure **multicast** on my MikroTik router  
  - Write a small C++/Python listener; measure packet drops and jitter with `tcpdump` or Wireshark  
- [ ] **Kernel Bypass Experiment (DPDK)**  
  - Install and configure **DPDK** on a Dell server  
  - Compare packet throughput/latency against regular Linux sockets  
- [ ] **MikroTik Router Tuning**  
  - Enable **hardware offload** if supported  
  - Benchmark router performance with iPerf or netperf  

**Milestones**  
- [ ] Measure round-trip latency for both standard networking and bypass methods  
- [ ] Be able to explain TCP congestion control or UDP multicast in depth  

---

### Observability & Monitoring

#### Reading Tasks
- [ ] Read “Prometheus: Up & Running” by Brian Brazil  
- [ ] Study “BPF Performance Tools” by Brendan Gregg to learn about eBPF  

#### Project Tasks
- [ ] **Prometheus & Grafana Setup**  
  - Deploy Prometheus on a central server; configure scrapers on all lab nodes  
  - Create **Grafana dashboards** to track CPU usage, network latency, and disk I/O  
- [ ] **Real-Time Logging Pipeline**  
  - Configure Fluent Bit or Logstash for log ingestion  
  - Use **structured JSON logging** for better correlation  
- [ ] **eBPF Tracing**  
  - Write bpftrace scripts to measure system call latency or monitor packet flow  
  - Investigate kernel-level performance bottlenecks in real time  

**Milestones**  
- [ ] Have real-time alerts for latency spikes beyond a chosen threshold  
- [ ] Be able to troubleshoot system issues using logs, metrics, and eBPF traces  

---

### High-Performance Programming & Concurrency

#### Reading Tasks
- [ ] Read “The Art of Multiprocessor Programming” by Herlihy & Shavit  
- [ ] Review “Effective C++” by Scott Meyers for best practices in C++  

#### Project Tasks
- [ ] **Lock-Free Ring Buffer**  
  - Implement a **single-producer, single-consumer** ring buffer using `std::atomic`  
  - Benchmark throughput under various concurrency settings  
- [ ] **High-Performance Order Book Simulation**  
  - Write a **multi-threaded** order-matching engine in C++  
  - Focus on **cache alignment** to avoid false sharing  
- [ ] **Parallel Data Processing**  
  - Parse large data files in parallel using **OpenMP** or **std::thread**  
  - Profile concurrency overhead using `perf` or Intel VTune  

**Milestones**  
- [ ] Understand how to avoid **race conditions** and false sharing  
- [ ] Be able to measure concurrency performance (messages/sec, CPU usage, etc.)  

---

### Hardware Acceleration & FPGA/Electronics

#### Reading Tasks
- [ ] Read “FPGA Prototyping by VHDL Examples” by Pong P. Chu (or use similar Verilog resources)  
- [ ] Check Intel, Xilinx, Mellanox whitepapers on ultra-low-latency networking  

#### Project Tasks
- [ ] **Precision Time Protocol (PTP) Setup**  
  - Configure PTP on my MikroTik router and Dell servers  
  - Compare **nanosecond-level** sync accuracy to NTP  
- [ ] **FPGA-Based Timestamping** (If I have an FPGA board)  
  - Implement a basic **packet timestamping** module  
  - Use an **oscilloscope** to measure real-world latency  
- [ ] **NIC Offload & Kernel Bypass**  
  - Experiment with **Solarflare Onload** or **Mellanox OFED** drivers  
  - Compare microsecond-level latency improvements over standard networking  

**Milestones**  
- [ ] Achieve sub-millisecond or even microsecond-level timing accuracy across the lab  
- [ ] Get practical experience with an FPGA or advanced NIC offloads  

---


## Routines

<div className={"flex mx-15"}>

  <div>
    ### Weekday Schedule (Mon–Fri)

    | Time               | Activity                        |
    |--------------------|---------------------------------|
    | 9:00 AM – 5:00 PM  | Work                             |
    | 5:00 PM – 5:30 PM  | Break      |
    | 5:30 PM – 6:45 PM  | Gym                              |
    | 6:45 PM – 7:30 PM  | Dinner                   |
    | 7:30 PM – 8:30 PM  | Focused Study (Reading/Theory)   |
    | 8:00 PM – 9:00 PM  | Hands-on Project/Lab             |
    | 9:00 PM – 9:30 PM  | Daily LeetCode Problem           |
    | 9:30 PM onwards    | Relax / Wind-down                |
  </div>
  <div className="grow"/>
  <div>
    ### Weekend Schedule (Saturday & Sunday)

    | Time                   | Activity                                  |
    |------------------------|---------------------------------------|
    | 9:00 AM – 11:00 AM     | Deep-dive Reading & Theory            |
    | 11:15 AM – 1:00 PM     | Hands-on Projects & Labs              |
    | 11:00 AM – 1:00 PM     | Break / Errands            |
    | 1:00 PM – 2:00 PM      | Lunch                                 |
    | 2:00 PM – 5:00 PM      | Project Work (Practical)              |
    | 5:00 PM – 6:30 PM      | Dinner / Leisure / Break              |
    | 6:30 PM – 8:00 PM      | Extended LeetCode Session             |
    | 8:00 PM – 8:30 PM      | Weekly Review & Planning               |
    | 8:30 PM onwards        | Free time                             |
  </div>
</div>
